\subsection{Digital Signatures}
Digital signature schemes allow a signer $S$ who has established a public key \emph{pk} to \emph{sign} a message \emph{m} in such a way that any other party who knows \emph{pk} (and knows that this public key was established by $S$) can \emph{verify} that \emph{m} originated from $S$ and has not been modified in any way~\cite{katz_lindell}.
The syntax of a digital signature scheme is formally defined in Definition~\ref{def:digital_signature}.

\begin{defn}[Signature scheme syntax~\cite{katz_lindell}]
	\label{def:digital_signature}
	We call a \textsf{signature scheme} is a tuple of probabilistic polynomial-time algorithms $\Pi = \textsf(Gen, Sign, Ver)$ satisfying the following:
	\begin{enumerate}
		\item The \textsf{key-generation algorithm Gen} takes as input a security parameter $1^\kappa$ and outputs a pair of keys (pk, sk). These are called the \textsf{public key} and the \textsf{private key}, respectively.
		\begin{equation*}
			(sk, pk) \leftarrow \textsf{Gen}(1^\kappa)
		\end{equation*}
		\item The \textsf{signing algorithm Sign} takes as input a private key sk and a message m from some underlying message space. It outputs a signature $\sigma$.
		\begin{equation*}
			\sigma \leftarrow \textsf{Sign}_{sk}(m)
		\end{equation*}
		\item The deterministic \textsf{verification algorithm Ver} takes as input a publock key pk, a message m and a signature $\sigma$. It outputs a bit b, with $b = 1$ meaning VALID and $b = 0$ meaning INVALID. 
		\begin{equation*}
			\textsf{Ver}_{pk}(m, \sigma) = 0 \text{ or } 1
		\end{equation*}
		We require that for every $\kappa$, every (pk, sk) output by $\textsf{Gen}(1^\kappa)$ and every message m in the appropriate underlying plaintext space, it holds that
		\begin{equation*}
			\textsf{Ver}_{pk}(m, \textsf{Sign}_{sk}(m)) = 1
		\end{equation*} 
	\end{enumerate}
\end{defn}

\noindent
\textbf{Correctness of signature schemes.}
We say that $\sigma$ is a \emph{valid signature} on a message \emph{m} with respect to public key \emph{pk} if $\textsf{Ver}_{pk}(m,\sigma) = 1$. We formally define the correctness of a signature scheme $\Pi = \textsf{(Gen, Sign, Ver)}$ using the $\textsf{Sig-correct}_{\Pi}(\kappa, m)$ experiment for security paramerter $\kappa$ and every message $m$ given in Algorithm~\ref{alg:sig-correct}.

\begin{algorithm}[h]
		\caption{\label{alg:sig-correct} The \textsf{Sig-correct} signature experiment}
		\begin{algorithmic}[1]
			\Function{$ \textsf{Sig-correct}_{\Pi}$}{$\kappa, m$}
				\Let{(pk, sk)}{\textsf{Gen}(1^\kappa)}
				\Let{(\sigma)}{\textsf{Sign}_{sk}(m)}
				\If{$\textsf{Ver}_{pk}(m, \sigma) = 1$}
					\State\Return 1
				\EndIf
				\State\Return 0
			\EndFunction
		\end{algorithmic}
\end{algorithm}

\begin{defn}[Correctness of signature scheme]
	\label{def:singature_correctness}
	A signature scheme $\Pi = (\textsf{Gen, Sign, Ver})$ is correct if for every $m$ from the underlying message space there exists a negligible function \textsf{negl($\cdot$)} such that:
	\begin{equation*}
		Pr[\textsf{Sig-correct}_{\Pi}(\kappa, m) = 0] \leq \textsf{negl}(\kappa)
	\end{equation*}
\end{defn}

\noindent
\textbf{Security of signature schemes.}
Given a public key \emph{pk} generated by a signer $S$, we say that an adversary outputs a \emph{forgery} if she outputs a message \emph{m} along with a valid signature $\sigma$ on \emph{m} and \emph{m} was not previously signed by $S$, since in this case the adversary could simply copy the originally signed message. \emph{Security} of a digital signature scheme means that an adversary cannot output forgery even if she is allowed to obtain Signatures on many other messages of her choice.

We formally define the security of a signature scheme $\Pi = \textsf{(Gen, Sign, Ver)}$ using the $\textsf{Sig-forge}_{\mathcal{A}, \Pi}(\kappa)$ experiment for adversary $\mathcal{A}$ and security paramerter $\kappa$ given in Algorithm~\ref{alg:sig-forge}. 
In this experiment we consider that the adversary is given $pk$ and oracle access to $\textsf{Sign}_{sk}(\cdot)$. This oracle returns a valid signature $\textsf{Sign}_{sk}(m)$ for any message $m$ of the adversary's choice. Let $Q$ denote the set of messages whose signatures were requested by $\mathcal{A}$.

\begin{algorithm}[h]
		\caption{\label{alg:sig-forge} The \textsf{Sig-forge} signature experiment}
		\begin{algorithmic}[1]
			\Function{$ \textsf{Sig-forge}^{cma}_{\mathcal{A}, \Pi}$}{$\kappa$}
				\Let{(pk, sk)}{\textsf{Gen}(1^\kappa)}
				\Let{(m, \sigma)}{\mathcal{A}(pk)}
				\If{$\textsf{Ver}_{pk}(m, \sigma) = 1 \wedge m \notin Q$}
					\State\Return 1
				\EndIf
				\State\Return 0
			\EndFunction
		\end{algorithmic}
\end{algorithm}

\begin{defn}[Security of signature scheme~\cite{katz_lindell}]
	\label{def:singature_security}
	A signature scheme $\Pi = (\textsf{Gen, Sign, Ver})$ is \textsf{existentially unforgeable under an adaptive chosen-message attack } if for all PPT adversaries $\mathcal{A}$, there exists a negligible function \textsf{negl($\cdot$)} such that:
	\begin{equation*}
		Pr[\textsf{Sig-forge}^{cma}_{\mathcal{A}, \Pi}(\kappa) = 1] \leq \textsf{negl}(\kappa)
	\end{equation*}
\end{defn}