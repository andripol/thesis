\subsection{\textit{Smooth} and \textit{Thorny} blocks}
In order to be applied under velvet fork, a protocol has to change in a
backwards-compatible manner. In essence, any additional information coming
with the protocol upgrade is transparent to the non-upgraded players. This
transparency towards the non-upgraded parties requires any block that conforms
only to the old protocol rules to be considered a valid one. Considering
NIPoPoWs under a velvet fork, any block is to be checked for its validity
regardless the validity of the NIPoPoWs protocol's additional information,
which is the interlink structure.

A block generated by the adversary could thus contain arbitrary data in the interlink
and yet be appended in the chain adopted by an honest party. In case that trash
data are stored in the structure this could be of no harm for the protocol routines,
since such blocks will be treated as non-upgraded. In the context of the attack
that will be presented in the following section, we examine the case where the
adversary includes false interlink pointers. 

An interlink pointer is the hash of a block. A correct interlink pointer of a block $b$
for a specific level $\mu$ is a pointer to the most recent $b$'s ancestor of level
$\mu$. From now on we will refer to correct interlink pointers as \emph{smooth pointers}.
Pointers of the 0-level \textit{(prevIds)} are always smooth because of the
performed proof-of-work.

\begin{defn}{\textbf{Smooth Pointer}}
	\textit{A smooth pointer of a block $b$ for a specific level $\mu$ is the interlink 
	pointer to the most recent $\mu$-level ancestor of $b$.}
	\label{defn:smooth_pointer}
\end{defn}


A non-smooth pointer may not point to the most recent ancestor of level $\mu$, or even point to a superblock of a forked chain, as shown in Figure \ref{fig:false_interlink}.

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.6]{figures/false_interlink.png}
	\end{center}
	\caption{\textit{A non-smooth pointer of an adversarial block, colored black,
	in an honest player's chain.}}
	\label{fig:false_interlink}
\end{figure}

In the same manner it is possible that a false interlink contain arbitrary pointers to blocks of any chain as illustrated in Figure \ref{fig:thorny_block}. The interlink pointing to arbitrary directions resembles a thorny bush, so we will refer to blocks containing false interlink information as \emph{thorny}. 

\begin{defn}{\textbf{Thorny Block}}
	\textit{A thorny block is a block which contains at least one non-smooth interlink pointer.}
	\label{defn:thorny_block}
\end{defn}

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.75]{figures/thorny_block.pdf}
	\end{center}
	\caption{\textit{A thorny block appended in an honest player's chain. The dashed arrows
	are interlink pointers.}}
	\label{fig:thorny_block}
\end{figure}

Opposite of the thorny are the \emph{smooth} blocks, which may be blocks generated by non-upgraded players or blocks generated by upgraded players and contain only smooth pointers in their interlink.

\begin{defn}{\textbf{Smooth Block}}
	\textit{A smooth block is any block which is not thorny.}
	\label{defn:smooth_block}
\end{defn}

\subsection{Suffix Proofs}

\subsubsection{The Chainsewing Attack}
\import{sections/nipopows_velvet_fork/}{chainsewing_attack.tex}

\subsection{Protocol Update}
\import{sections/nipopows_velvet_fork/}{protocol_update.tex}
