\subsection{Infix Proofs}
The security of the original NIPoPoWs protocol suffers under velvet fork conditions for the case of
infix proofs as well. Again, since blocks containing incorrect interlink pointers are accepted in the 
chain, the adversary may create an infix proof for a transaction included in a block mined on a
different chain. This attack is presented in detail in the following.

An infix proof attack when applying the original protocol under a velvet fork should be obvious
after our previous discussion. So consider the updated protocol for secure suffix proofs as
described in the previous section. A problem here is that in the updated protocol some blocks
are excluded from the interlink, while we should still be able to provide proofs for transactions
included in any block of the chain.

For this reason, let us naively consider an additional protocol patch suggesting to include
a second interlink data structure in each block, which will be updated without any block exclusion,
just as described in the original protocol and will be used for constructing infix proofs only. In
order to be secure we could think of allowing using pointers of the second interlink only for the
\textit{followDown} part of the algorithm. But still, the adversary may use an invalid pointer of a
block visited during the \textit{followDown} procedure and jump to a block of another chain providing 
a transaction inclusion proof concerning that block. This attack is illustrated in
Figure \ref{fig:infix_attack}.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.9\columnwidth]{figures/infix_attack.pdf}
	\end{center}
	\caption{Adversarial fork chain $C_A$ and an adversarial infix proof based on the chain
	 adopted by an honest player. Wavy lines imply one or more blocks. Blocks generated by the
	 adversary are colored black. Dashed arrows represent interlink pointers included in the proof
	 as part of the \textit{followDown} procedure. The adversary provides infix proof for a
	 transaction in block b'. }
	\label{fig:infix_attack}
\end{figure}

Thus giving the ability to utilize invalid pointers even in a narrow block window can break the
security of our protocol. 

\subsubsection*{Protocol patch for NIPoPoWs infix proofs under velvet fork}
In order to construct secure infix proofs under velvet fork conditions, we suggest the following additional protocol patch: each upgraded miner constructs and updates an authenticated data structure for all the blocks in the chain. We suggest Merkle Mountain Ranges \emph{(MMR)} for this structure. Now a velvet block's header additionally includes the root of this MMR.

After this additional protocol change the notion of a smooth block changes as well. Smooth blocks are now considered the blocks that contain truthful interlinks and valid MMR root too. A valid MMR root denotes the MMR that contains all the blocks in the chain of an honest full node. Note that a valid MMR contains all the blocks of the longest valid chain, meaning both smooth and thorny. An invalid MMR constructed by the adversary may contain a block of a fork chain. Consequently an upgraded prover has to maintain a local copy of this MMR locally, in order to construct correct proofs. This is crucial for the security of infix proofs, since keeping the notion of a smooth block as before would allow an adversary to produce a block $b$ in an honest party's chain, with $b$ containing a smooth interlink but invalid MMR, so she could succeed in providing an infix proof about a block of a fork chain.

\subsubsection*{The velvet infix prover and verifier}
Considering this addtional patch we can now define the final algorithms for the honest miner, infix and suffix prover, as well as for the infix verifier. Because of the new notion of smooth block, the function \textit{isSmoothBlock()} of Algorithm \ref{alg:smooth_chain_suffix} needs to be updated, so that the validity of the included MMR root is also checked. The updated function is given in Algorithm \ref{alg:isSmoothBlock_infix}. Considering that input $\chain_S$ is computed using Algorithm \ref{alg:smooth_chain_suffix} with the updated \textit{isSmoothBlock'()} function, \emph{Velvet updateInterlink} and \emph{Velvet Suffix Prover} algorithms remain the same as described in Algorithms \ref{alg:update_interlink}, \ref{alg:velvet_suffix_prover} repsectively. The velvet infix prover  given in Algorithms \ref{alg:velvet_infix_prover}, \ref{alg:velvet_infix_verifier} respectively.
In order to keep the algorithm generic enough for any infix-sensitive predicate, we provide the steps needed until the verification of the block of interest and consider that the specific predicate can be answered by a known algorithm given the block of interest. 
Given that the verifier is already synchronized to the longest valid chain, the infix verification algorithm only has to confirm
the Merkle-Tree inclusion proof $\pi_{b'}$ for the block of interest $b'$.

Details about the construction and verification of an MMR and the respective inclusion proofs can be found in \cite{ct}.
Note that equivalent solution could be formed by using any authenticated data structure that provides inclusion proofs of size logarithmic to the length of the chain. We suggest MMRs because of they come with efficient update operations.

\begin{algorithm}[h]
	\caption{\label{alg:isSmoothBlock_infix}Function isSmoothBlock'() for infix proof support}
	\begin{algorithmic}[1]
			\Function{\sf isSmoothBlock'}{$B$}
				\If{$B = \mathcal{G}$}
					\State\Return{$\true$}
				\EndIf
				\For{$p \in B.\textsf{interlink}$}
						\If{$\lnot \textsf{isSmoothPointer}(B, p)$}
							\State\Return{$\false$}
						\EndIf
				\EndFor
				\State\Return{$\textsf{containsValidMMR}(B)$}
			\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
	\caption{\label{alg:velvet_infix_prover}Velvet Infix Prover}
	\begin{algorithmic}[1]
			\Function{\sf ProveInfixVelvet}{$\chain_S, b$}
				\Let{(\pi,\chi)}{\textsf{ProveVelvet}(\chain_S)}
				\Let{\textsf{tip}}{\pi[-1]}
				\Let{\pi_b}{\textsf{MMRinclusionProof}(tip, b)}
				\State\Return{$(\pi_b,(\pi, \chi))$}
			\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
	\caption{\label{alg:velvet_infix_verifier}Velvet Infix Verifier}
	\begin{algorithmic}[1]
			\Function{\sf VerifyInfixVelvet}{$b, (\pi_b,(\pi,\chi))$}
				\Let{\textsf{tip}}{\pi[-1]}
				\State\Return{\textsf{VerifyInclProof(tip.$root_{MMR}$, $\pi_b$, $b$)}}
			\EndFunction
	\end{algorithmic}
\end{algorithm}




\subsubsection*{Maximum delay of an infix proof}
The problem with this infix proof construction is that in order to confirm a
transaction in a block of interest $b$ the prover has to provide an inclusion
proof for that block of interest using the Merkle Tree Root of a more recent
honestly generated block included in the infix proof. Obviously, there is a case
that there may be a number of consecutive adversarially generated blocks in the
chain   consisting the prefix of the chain. Thus, no inclusion proof can be provided
for any of these blocks until an honestly generated block is added in the chain and,
consequently in the infix proof.

We need to estimate an upper bound for the number of rounds a client has to
wait until the block of interest is buried under sufficient number of blocks
so that he can obtain the infix proof needed with high probability.

Consider $n_b$ is the upper bound on the consecutive rounds when the adversary could
possibly append blocks to the chain, without any honestly generated blocks in
between. The adversary mines either by following the selfish mining strategy or
not. The state of the chain we examine looks like in Figure \ref{fig:infix_delay}.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\columnwidth]{figures/infix_delay.pdf}
	\end{center}
	\caption{ \textbf{$n_b$} implies the number of consecutive
	 adversarially generated blocks in the chain.Wavy lines imply one or more blocks. Blocks generated by the
	 adversary are colored black.}
	\label{fig:infix_delay}
\end{figure}

Let $p_H$ the probability that a block is generated by an honest party during a round.
Then considering that collisions in RO model is a negligible event we have
$p_H = (n-t)qp$. Let $p_A$ be the probability that a block is generated by the
adversary during a round, then $p_A = tqp$. Consider $N_{bA}$ the random variable
for the number of consecutive blocks generated by the adversary in a total of $r$
rounds. Also let $N_{bH}$ the random variable for the number of blocks generated by
honest parties in total of $r$ rounds. 
Then we have that $N_{bA}$, $N_{bH}$ follow the Binomial Distribution with
probability $p_A$, $p_H$ respectively.

Because we require consecutive successful rounds for the adversary, we have:
\begin{equation}
	Pr[N_{bA} = n_b] = (r-n_b - 1) p_A^{n_b}(1-p_A)^{r-n_b}
\end{equation}

while for the honest players we have 
\begin{equation}
	Pr[N_{bH} \leq n_b] = \sum_{i=0}^{n_b} \binom nk p_H^{i}(1-p_H)^{r-i}
\end{equation}

If $N_b$ is the random variable denoting the number of consecutive rounds that
adversarially generated blocks are appended to the chain, we have:

\begin{equation}
	Pr[N_b = n_b] = Pr[N_{bA} = n_b] \cdot Pr[N_{bH} \leq n_b]
\end{equation}

since the two events are independent.
