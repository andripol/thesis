\section{Protocol Update}
In order to eliminate the Chainsewing Attack we propose an update to the velvet NIPoPoW protocol. The core problem is that, in her suffix proof, the adversary was able to claim not only blocks of shorter forked chains, but also arbitrarily long parts of the chain generated by an honest party. Since thorny blocks are accepted as valid, the verifier cannot distinguish blocks that actually belong in a chain from blocks that only seem to belong in the same chain because they are pointed to from a thorny block.

The idea for a secure protocol is to distinguish the smooth from the thorny blocks, so that smooth blocks can never point to thorny blocks. In this way we can make sure that thorny blocks acting as passing points to fork chains, as block $a'$ does in Figure~\ref{fig:attack}, cannot be pointed to by honestly generated blocks. Therefore, the adversary cannot utilize honest mining power to construct a stronger suffix proof for her fork chain. Our velvet construction mandates that honest miners create blocks that contain interlink pointers pointing only to previous smooth blocks. As such, newly created smooth blocks can only point to previously created smooth blocks and not thorny blocks. Following the terminology of Section~\ref{sec:velvet}, the smoothness of a blocks in this new construction is a stricter notion than smoothness in the na\"ive construction.

In order to formally describe the suggested protocol patch, redefine the notion of a smooth block recursively by introducing the notion of a smooth interlink pointer.

\begin{definition}[Smooth Pointer]
  A \emph{smooth pointer} of a block $b$ for a specific level $\mu$ is the interlink pointer to the most recent $\mu$-level smooth ancestor of $b$.
	\label{defn:smooth_pointer}
\end{definition}

We describe a protocol patch that operates as follows. The superblock NIPoPoW protocol works as usual but each honest miner constructs smooth blocks whose interlink contains only smooth pointers; thus it is constructed excluding thorny blocks. In this way, although thorny blocks are accepted in the chain, they are not taken into consideration when updating the interlink structure for the next block to be mined. No honest block could now point to a thorny superblock that may act as the passing point to the fork chain in an adversarial suffix proof. Thus, after this protocol update the adversary is only able to inject adversarially generated blocks from an honestly adopted chain to her own fork.
At the same time, thorny blocks cannot participate in an honestly generated suffix proof except for some blocks in the proof's suffix $(\chi)$. This argument holds because thorny blocks do not form a valid chain along with honestly mined blocks anymore. Consequently, as far as the blocks included in a suffix proof are concerned, we can think of thorny blocks as belonging in the adversary's fork chain for the $\pi$ part of the proof,  which is the comparing part between proofs. Figure~
\ref{fig:injection} illustrates this remark. The velvet NIPoPoW verifier is also modified to only follow interlink pointers, and never previd pointers (which could be pointing to thorny blocks, even if honestly generated).

\begin{figure*}[h!]
	\begin{center}
		\includegraphics[width=\textwidth]{figures/injection.pdf}
	\end{center}
	\caption{The adversarial fork chain $\chain_A$ and chain $\chain_B$ of an honest party. Thorny blocks are colored black. Dashed arrows represent interlink pointers. Wavy lines imply one or more blocks. After the protocol update, when an adversarially generated block is sewed from $\chain_B$ into the adversary's suffix proof the verifier conceives $\chain_A$ as longer and $\chain_B$ as shorter. \textbf{I:} The real picture of the chains. \textbf{II:} Equivalent picture from the verifier's perspective considering the blocks included in the corresponding suffix proof for each chain.}
	\label{fig:injection}
\end{figure*}

With this protocol patch we conclude that the adversary cannot usurp honest mining power to her fork chain. This comes with the cost that the honest prover cannot utilize thorny blocks despite belonging in the honest chain. Due to this fact we define the Velvet Honest Majority Assumption for (1/4)-bounded adversary under which the security of the protocol is guaranteed.

\begin{definition}[Velvet Honest Majority]
	Let $n_h$ be the number of upgraded honest miners. Then $t$ out of total $n$ parties are corrupted such that $\dfrac{t}{n_h} < \dfrac{1 - \delta_v}{3} $.
	\label{defn:velvet_honest_majority}
\end{definition}

The number of upgraded honest miners can be calculated via the ``velvet parameter''.

\begin{defn}[Velvet Parameter]
	\textit{Let $g$ be the velvet parameter for NIPoPoW protocols.  Then if $n_h$ the upgraded honest miners and $n$ the total number of miners $t$ out of which are corrupted, it holds that $n_h = g (n - t)$.}
	\label{defn:velvet_honest_majority}
\end{defn}

The following Lemmas come as immediate results from the suggested protocol
update.

\begin{lemma}
	A velvet suffix proof constructed by an honest party cannot contain any thorny block.
	\label{lemm:smooth_honest_suffix}
\end{lemma}
%\begin{proof}
%	The statement holds by construction.
%\end{proof}

\begin{lemma}
	Let $\mathcal{P_A} = (\pi_\mathcal{A}, \chi_\mathcal{A})$ be a velvet suffix proof constructed by the adversary and block $b_s$, generated at round $r_s$, be the most recent smooth block in the proof. Then $\forall r:r < r_s$ no thorny blocks generated at round $r$ can be included in $\mathcal{P_A}$.
	\label{lemm:smooths_before_smooth}
\end{lemma}
\begin{proof}
By contradiction. Let $b_t$ be a thorny block generated at some round $r_t < r_s$. Suppose for contradiction that $b_t$ is included in the proof. Then, because $\mathcal{P_A}$ is a valid chain as for interlink pointers, there exist a block path made by interlink pointers starting from $b_s$ and resulting to $b_t$. Let $b'$ be the most recently generated thorny block after $b_t$ and before $b_s$ included in $\mathcal{P_A}$. Then $b'$ has been generated at a round $r'$ such that $r_t \leq r' < r_s$. Then the block right after block $b'$ in $\mathcal{P_A}$ must be a thorny block since it points to $b'$ which is thorny. But $b'$ is the most recent thorny block after $b_t$, thus we have reached a contradiction.
\end{proof}

\begin{lemma}
	Let $\mathcal{P_A} = (\pi_\mathcal{A}, \chi_\mathcal{A})$ be a velvet suffix proof constructed by the adversary. Let $b_t$ be the oldest thorny bock included in $\mathcal{P_A}$ which is generated at round $r_t$. Then any block $b = \{b: b \in \mathcal{P_A} \wedge \text{b generated at }r \geq r_t \}$ is thorny.
	\label{lemm:thorny_after_thorny}
\end{lemma}
\begin{proof}
By contradiction. Suppose for contradiciton that $b_s$ is a smooth block generated at round $r_s > r_t$. Then from Lemma \ref{lemm:smooths_before_smooth} any block generated at round $r < r_s$ is smooth. But $b_t$ is generated at round $r_t < r_s$ and is thorny, thus we have reached a contradiction.
\end{proof}

The following corollary emerges immediately from Lemmas \ref{lemm:smooths_before_smooth}, \ref{lemm:thorny_after_thorny}. This result is illustrated in Figure \ref{fig:adversarial_velvet_proof}.

\begin{corollary}
	Any adversarial proof $\mathcal{P_A} = (\pi_\mathcal{A}, \chi_\mathcal{A})$ containing both smooth and thorny blocks consists of a prefix smooth subchain followed by a suffix thorny subchain.
	\label{cor:adversarial_proof_scheme}
\end{corollary}

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.7\columnwidth]{figures/adversarial_velvet_proof.pdf}
	\end{center}
	\caption{General case of the adversarial velvet suffix proof $\mathcal{P_A} = (\pi_\mathcal{A}, \chi_\mathcal{A})$ consisting of an initial part of smooth blocks followed by thorny blocks.}
	\label{fig:adversarial_velvet_proof}
\end{figure}
We now describe the algorithms needed by the upgraded miner, prover and verifier. The upgraded miner acts as usual except for including the interlink of the newborn block in the coinbase transaction. In order to construct an interlink containing only the smooth blocks, the miner keeps a copy of the ``smooth chain'' ($\chain_S$) which consists of the smooth blocks existing in the original chain $\chain$. The algorithm for extracting the smooth chain out of $\chain$ is given in Algorithm~\ref{alg:smooth_chain_suffix}. Function \textit{isSmoothBlock(B)} checks whether a block $B$ is smooth by calling \textit{isSmoothPointer(B,p)} for every pointer $p$ in $B$'s interlink. Function \textit{isSmoothPointer(B,p)} returns \emph{true} if $p$ is a valid pointer, in essence a pointer to the most recent \emph{smooth velvet} for the level denoted by the pointer itself. The \textit{updateInterlink} algorithm is given in Algorithm~\ref{alg:update_interlink}. It is the same as in the case of a soft fork, but works on the smooth chain $\chain_S$ instead of $\chain$.

The construction of the velvet suffix prover is given in Algorithm~\ref{alg:velvet_suffix_prover}. Again it deviates from the soft fork case by working on the smooth chain $\chain_S$ instead of $\chain$.
Lastly, the Verify algorithm for the NIPoPoW suffix protocol remains the same as in the case of hard or soft fork, keeping in mind that no \emph{previd} links can be followed when verifying the ancestry of the chain to avoid hitting any thorny blocks.

\begin{algorithm}[h!]
	\caption{\label{alg:smooth_chain_suffix}Smooth chain for suffix proofs}
	\begin{algorithmic}[1]
			\Function{\sf smoothChain}{$\chain$}
				\Let{\chain_S}{\{\mathcal{G}\}}
				\Let{k}{1}
				\While{$\chain[-k] \neq \mathcal{G}$}
						\If{$\textsf{isSmoothBlock}(\chain[-k])$}
							\Let{\chain_S}{\chain_S \cup \chain[-k]}
						\EndIf
						\Let{k}{k + 1}
				\EndWhile
				\State\Return{$\chain_S$}
			\EndFunction

			\Function{\sf isSmoothBlock}{$B$}
				\If{$B = \mathcal{G}$}
					\State\Return{$\true$}
				\EndIf
				\For{$p \in B.\textsf{interlink}$}
						\If{$\lnot \textsf{isSmoothPointer}(B, p)$}
							\State\Return{$\false$}
						\EndIf
				\EndFor
				\State\Return{$\true$}
			\EndFunction

			\Function{\sf isSmoothPointer}{$B, p$}
				\Let{b}{\textsf{Block}(B.\textsf{prevId})}
				\While{$b \neq p$}
						\If{$\textsf{level}(b) \geq \textsf{level}(p) \land \textsf{isSmoothBlock}(b)$}
							\State\Return{$\false$}
						\EndIf
						\If{$b = \mathcal{G}$}
							\State\Return{$\false$}
						\EndIf
						\Let{b}{\textsf{Block}(b.\textsf{prevId})}
				\EndWhile
				\State\Return{$\textsf{isSmoothBlock}(b)$}
			\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h!]
		\caption{\label{alg:update_interlink}Velvet updateInterlink}
		\begin{algorithmic}[1]
				\Function{\sf updateInterlinkVelvet}{$\chain_S$}
						\Let{B'}{\chain_S[-1]}
						\Let{\textsf{interlink}}{B'.\textsf{interlink}}
						\For{$\mu = 0$ to $\textsf{level}(B')$}
								\Let{\textsf{interlink}[\mu]}{\textsf{id}(B')}
						\EndFor
						\State\Return$\textsf{interlink}$
				\EndFunction
		\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h!]
		\caption{\label{alg:velvet_suffix_prover}Velvet Suffix Prover}
		\begin{algorithmic}
				\Function{\sf ProveVelvet$_{m,k}$}{$\chain_S$}
					\Let{B}{\chain_S[0]}
					\For{$\mu = \lvert \chain_S[-k].\textsf{interlink} \rvert$ down to $0$}
						\Let{\alpha}{\chain_S[{:}-k]\{B{:}\}\upchain^\mu}
						\Let{\pi}{\pi \cup \alpha}
						\Let{B}{\alpha[-m]}
					\EndFor
					\Let{\chi}{\chain_S[-k{:}]}
					\State\Return$\pi\chi$
				\EndFunction
		\end{algorithmic}
\end{algorithm}

\subsubsection{Impossibility of a secure protocol for (1/2)-bounded adversary}
During our study on the problem we failed to prove the security of a protocol
construction under the hypothesis $(\frac{1}{2})$-bounded adversary, though we tried for a number of them. We finally concluded that
such a secure NIPoPoW construction is impossible under velvet fork conditions.
Though it is hard to provide a typical proof for this claim, as one should consider
any possible construction, we try to argue for it in this section. Our hope is that this discussion will help the reader to obtain a deeper understanding on the problem, as it resembles our own research journey.

\textbf{Claim:} \textit{Assume $t$ adversarial out of $n$ total parties and $n_h = g(n-t)$ the number of upgraded honest parties.
There is no construction for superblock NIPoPoW suffix proofs under velvet fork conditions
which is both succinct and secure for every adversary, such that
$\dfrac{t}{n_h} < (1 - \delta)$.}

\textit{Discussion.} As explained earlier, since the adversary may use the interlink structure so as to include pointers to arbitrary blocks,  she may construct her own
chain history utilizing the non-smooth pointers included in the thorny blocks she
generates. Such an example is given in Figure \ref{fig:generic_attack}. Let us consider a protocol construction $p$ which allows for  superblock NIPoPoW velvet suffix proofs and is secure for 1/2-bounded adversary. Our main
goals are $p$ to be both secure and succinct. We are even willing to loose our non-interactivity
limitations to make it possible to challenge the submitted proofs, so that an honest
player can contest against an inconsistent proof, if this would be of needed. However, note that in such a case the same power
to challenge any submitted proof is also provided to the adversary.

Now assume an adversary of $ \dfrac{1-\delta}{2} < \dfrac{t}{n_h} < 1-\delta $, meaning that the adversarial parties count more than 1/3 but less than the 1/2 of the upgraded honest parties. Then, by following a selfish mining strategy~\cite{backbone}\cite{selfish} it
is possible for the adversary to maintain more than $50\%$ of the blocks in the longest valid chain. In particular,
consider that the adversary mines selfish, meaning that for every block that she mines,
she does not immediately announce it to the network. Instead, she waits until an honestly generated block is announced and at this time she announces her block too. In the worst case, consider that the adversary has a
network advantage regarding the relay of her blocks. Thus in case of two competing
blocks in a round the adversarial one will be appended to the chain, while the
honest block is discarded as a temporary fork. Because of this attack
the block distribution in the chain between adversarial and honest parties can be as illustrated in Figure
\ref{fig:selfish_mining_pie} in the worst case scenario. For (1/3) adversary half of the blocks in the
chain are expected to be adversarial, while for (1/2) adversary no honest blocks
are included in the chain.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.8]{figures/selfish_mining_pie.pdf}
	\end{center}
	\caption{Pie chart of adversarially and honestly generated blocks appended in 
	the chain during a round set S. Part \textbf{A} stands for blocks mined by the
	adversary while \textbf{B} for blocks mined by honest players. Lined out parts
	denote honestly mined blocks that were defeated by adversarially mined ones in
	the same round due to selfish mining.\textbf{I.} With $t = n/3$, $50\%$ of the
	total blocks are adversarially generated in the worst case scenario. \textbf{II.}
	With $t > n/3$, more than half of the total blocks are adversarially generated in
	the worst case scenario.}
	\label{fig:selfish_mining_pie}
\end{figure}

Now observe that in the chainsewing attack the $prevId$ block property between two sequential blocks is violated while constructing an attacking proof. Therefore, an initial naive approach would be to resort to the $prevId$ pointers which have been validated with the proof-of-work, in order to contest and unveil an invalid proof chain. However, since the main purpose of our work is to achieve
succinctness, the $prevId$ relations could not be utilized in a viable manner
in order to contest adversarial proofs, as it would require data of linear length
to that of the whole chain.  We thus conclude that we should mostly rely on the
information given by the interlink pointers as far as the validity of any proof
is concerned, or else we have no chance in keeping our protocol construction efficient.

Now assume, to honest parties' favor, that given a block $b$ we have the means to efficiently inspect
all the blocks in the intelrinked chain where $b$ belongs. This could be implemented by adding an appropriate Merkle-Mountain-Range root in each block header. Now one should consider the following choices regarding the next step in the protocol construction: 
\begin{enumerate}
	\item either require proofs that additionally contain consistency sub-proofs as for the interlinked chain history of each block included or
	\item permit inconsistencies in the interlinked chain history of the included blocks in order to avoid excluding adversarially generated blocks from honest proofs, with the hope that an honest prover will be able to unveil a submitted proof that utilizes invalid interlink pointers by using the history commited in the MMRs. 
\end{enumerate}
Observe that neither of these approaches can provide a secure protocol. 

In the first case, the requirement for consistency sub-proofs essentially compels the adversary to comply to the honest chain history, if she means to utilize honeslty generated blocks in her proof. However, observe that the adversary can even maintain a consistent interlink chain 
by using only her own mined blocks and these blocks may overwhelm
the honestly generated ones, as shown in Figure~\ref{fig:selfish_mining_pie}. At the same time, the honest provers are obliged to exclude the inconsistent adversarially generated blocks from their proofs, thus being doomed to utilize only a minority of blocks resulting to non-winning proofs with non-negligible probability. 

In the second case, in an attempt to overcome the shortcomings of the previous approach, no chain consistency proofs are required. The idea is that an honest prover inspecting the submitted proofs can detect an invalid proof and try to efficiently prove the broken $prevId$ property. Remember that he cannot just send the $prevId$ pointers, as this would destroy the succinctness of our protocol as discussed before. He should use the interlink chain history commintments instead. Consider that after inspecting an invalid proof the honest prover observes a block $b$ pointing to a superblock $b'$ of level $\mu_{b'}$, but $b,b'$ are not connected with $prevId$ pointers. This means that $b'$ belongs to a fork chain. In consequence, any honest block generated after $b$ contains a commitment for the correct $\mu_{b'}$ superblock that should be pointed by the adversarial block $b$. Now consider that the honest prover can submit a merkle proof denoting the inconsistency in order to make the adversarial proof fail. However, this power of calling into question the consistency of a block in the proof is also a power for the adversary, who can question the consistency of honest blocks in an honest proof based on any adversarial block included in the proof. The problem is, that the verifier has no way to distinguish the chain history commitments between honest and adversarial parties. Consequently, this approach would fail to construct a secure protocol too.

We conclude that such a protocol $p$, both succinct and secure, could not exist for (1/2)-bounded adversary.

%\subsubsection{Solution for (1/3)-bounded adversary}
%The vulnerability that makes this attack possible is the acceptance of thorny blocks. Since we operate under a velvet fork we cannot eliminate such blocks,  but we need, however, to restrict the adversary from being able to claim portion of another chain as part of her own fork chain. The key observation on the Chainsewing Attack is that the adversary needs at least one adversarially generated block in an honest player's chain, in order to create a path of superpointers connecting blocks of two, or more, diverse chains. The final proof chain will make use of this crossing point and may contain both honest or adversarial blocks. 
%% intuitive reference to 1/4 adversary 
%In case the proof contains only adversarial blocks, the attack cannot harm security for an adversary of less than $1/3$ of the total hashing power. This fact will be clear in the security proof section. In short, as argued in the previous section an adversary of $1/3$ of the total hashing power may contribute at most $ 50\% $ of the total blocks in the longest valid chain. An attacker of more than $1/3$ hashing power could dominate as of total hashing power expressed in mined blocks in the chain, while the inverse would be true for an attacker of less hashing power than this threshold.

%So in order to be successful, the attacker needs to also ``sew`` honestly generated blocks. Thus there will be at least one honest block in the superblock path which connects $a$ and $a'$, pointing to an adversarial thorny block.

%The idea is to ban all blocks generated by honest players from participating in this superblock path. In this way the adversary could not misuse hashing power of the honest players and the sewed blocks could only be adversarially generated, thus the attack could never succeed for an adversary of less than $1/3$ of the total hashing power.