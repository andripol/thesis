\section{Protocol Update}
In order to eliminate the Chainsewing Attack we propose an update to the velvet NIPoPoW protocol. The core problem is that, in her suffix proof, the adversary was able to claim not only blocks of shorter forked chains, but also arbitrarily long parts of the chain generated by an honest party. Since thorny blocks are accepted as valid, the verifier cannot distinguish blocks that actually belong in a chain from blocks that only seem to belong in the same chain because they are pointed to from a thorny block.

The idea for a secure protocol is to distinguish the smooth from the thorny blocks, so that smooth blocks can never point to thorny blocks. In this way we can make sure that thorny blocks acting as passing points to fork chains, as block $a'$ does in Figure~\ref{fig:attack}, cannot be pointed to by honestly generated blocks. Therefore, the adversary cannot utilize honest mining power to construct a stronger suffix proof for her fork chain. Our velvet construction mandates that honest miners create blocks that contain interlink pointers pointing only to previous smooth blocks. As such, newly created smooth blocks can only point to previously created smooth blocks and not thorny blocks. Following the terminology of Section~\ref{sec:velvet}, the smoothness of a blocks in this new construction is a stricter notion than smoothness in the na\"ive construction.

In order to formally describe the suggested protocol patch, redefine the notion of a smooth block recursively by introducing the notion of a smooth interlink pointer.

\begin{definition}[Smooth Pointer]
  A \emph{smooth pointer} of a block $b$ for a specific level $\mu$ is the interlink pointer to the most recent $\mu$-level smooth ancestor of $b$.
	\label{defn:smooth_pointer}
\end{definition}

We describe a protocol patch that operates as follows. The superblock NIPoPoW protocol works as usual but each honest miner constructs smooth blocks whose interlink contains only smooth pointers; thus it is constructed excluding thorny blocks. In this way, although thorny blocks are accepted in the chain, they are not taken into consideration when updating the interlink structure for the next block to be mined. No honest block could now point to a thorny superblock that may act as the passing point to the fork chain in an adversarial suffix proof. Thus, after this protocol update the adversary is only able to inject adversarially generated blocks from an honestly adopted chain to her own fork.
At the same time, thorny blocks cannot participate in an honestly generated suffix proof except for some blocks in the proof's suffix $(\chi)$. This argument holds because thorny blocks do not form a valid chain along with honestly mined blocks anymore. Consequently, as far as the blocks included in a suffix proof are concerned, we can think of thorny blocks as belonging in the adversary's fork chain for the $\pi$ part of the proof,  which is the comparing part between proofs. Figure~
\ref{fig:injection} illustrates this remark. The velvet NIPoPoW verifier is also modified to only follow interlink pointers, and never previd pointers (which could be pointing to thorny blocks, even if honestly generated).

\begin{figure*}[h!]
	\begin{center}
		\includegraphics[width=\textwidth]{figures/injection.pdf}
	\end{center}
	\caption{The adversarial fork chain $\chain_A$ and chain $\chain_B$ of an honest party. Thorny blocks are colored black. Dashed arrows represent interlink pointers. Wavy lines imply one or more blocks. After the protocol update, when an adversarially generated block is sewed from $\chain_B$ into the adversary's suffix proof the verifier conceives $\chain_A$ as longer and $\chain_B$ as shorter. \textbf{I:} The real picture of the chains. \textbf{II:} Equivalent picture from the verifier's perspective considering the blocks included in the corresponding suffix proof for each chain.}
	\label{fig:injection}
\end{figure*}

With this protocol patch we conclude that the adversary cannot usurp honest mining power to her fork chain. This comes with the cost that the honest prover cannot utilize thorny blocks despite belonging in the honest chain. Due to this fact we define the Velvet Honest Majority Assumption for (1/4)-bounded adversary under which the security of the protocol is guaranteed.

\begin{definition}[Velvet Honest Majority]
	Let $n_h$ be the number of upgraded honest miners. Then $t$ out of total $n$ parties are corrupted such that $\dfrac{t}{n_h} < \dfrac{1 - \delta_v}{3} $.
	\label{defn:velvet_honest_majority}
\end{definition}

The number of upgraded honest miners can be calculated via the ``velvet parameter''.

\begin{defn}[Velvet Parameter]
	\textit{Let $g$ be the velvet parameter for NIPoPoW protocols.  Then if $n_h$ the upgraded honest miners and $n$ the total number of miners $t$ out of which are corrupted, it holds that $n_h = g (n - t)$.}
	\label{defn:velvet_honest_majority}
\end{defn}

The following Lemmas come as immediate results from the suggested protocol
update.

\begin{lemma}
	A velvet suffix proof constructed by an honest party cannot contain any thorny block.
	\label{lemm:smooth_honest_suffix}
\end{lemma}
%\begin{proof}
%	The statement holds by construction.
%\end{proof}

\begin{lemma}
	Let $\mathcal{P_A} = (\pi_\mathcal{A}, \chi_\mathcal{A})$ be a velvet suffix proof constructed by the adversary and block $b_s$, generated at round $r_s$, be the most recent smooth block in the proof. Then $\forall r:r < r_s$ no thorny blocks generated at round $r$ can be included in $\mathcal{P_A}$.
	\label{lemm:smooths_before_smooth}
\end{lemma}
\begin{proof}
By contradiction. Let $b_t$ be a thorny block generated at some round $r_t < r_s$. Suppose for contradiction that $b_t$ is included in the proof. Then, because $\mathcal{P_A}$ is a valid chain as for interlink pointers, there exist a block path made by interlink pointers starting from $b_s$ and resulting to $b_t$. Let $b'$ be the most recently generated thorny block after $b_t$ and before $b_s$ included in $\mathcal{P_A}$. Then $b'$ has been generated at a round $r'$ such that $r_t \leq r' < r_s$. Then the block right after block $b'$ in $\mathcal{P_A}$ must be a thorny block since it points to $b'$ which is thorny. But $b'$ is the most recent thorny block after $b_t$, thus we have reached a contradiction.
\end{proof}

\begin{lemma}
	Let $\mathcal{P_A} = (\pi_\mathcal{A}, \chi_\mathcal{A})$ be a velvet suffix proof constructed by the adversary. Let $b_t$ be the oldest thorny bock included in $\mathcal{P_A}$ which is generated at round $r_t$. Then any block $b = \{b: b \in \mathcal{P_A} \wedge \text{b generated at }r \geq r_t \}$ is thorny.
	\label{lemm:thorny_after_thorny}
\end{lemma}
\begin{proof}
By contradiction. Suppose for contradiciton that $b_s$ is a smooth block generated at round $r_s > r_t$. Then from Lemma \ref{lemm:smooths_before_smooth} any block generated at round $r < r_s$ is smooth. But $b_t$ is generated at round $r_t < r_s$ and is thorny, thus we have reached a contradiction.
\end{proof}

The following corollary emerges immediately from Lemmas \ref{lemm:smooths_before_smooth}, \ref{lemm:thorny_after_thorny}. This result is illustrated in Figure \ref{fig:adversarial_velvet_proof}.

\begin{corollary}
	Any adversarial proof $\mathcal{P_A} = (\pi_\mathcal{A}, \chi_\mathcal{A})$ containing both smooth and thorny blocks consists of a prefix smooth subchain followed by a suffix thorny subchain.
	\label{cor:adversarial_proof_scheme}
\end{corollary}

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.7\columnwidth]{figures/adversarial_velvet_proof.pdf}
	\end{center}
	\caption{General case of the adversarial velvet suffix proof $\mathcal{P_A} = (\pi_\mathcal{A}, \chi_\mathcal{A})$ consisting of an initial part of smooth blocks followed by thorny blocks.}
	\label{fig:adversarial_velvet_proof}
\end{figure}
We now describe the algorithms needed by the upgraded miner, prover and verifier. The upgraded miner acts as usual except for including the interlink of the newborn block in the coinbase transaction. In order to construct an interlink containing only the smooth blocks, the miner keeps a copy of the ``smooth chain'' ($\chain_S$) which consists of the smooth blocks existing in the original chain $\chain$. The algorithm for extracting the smooth chain out of $\chain$ is given in Algorithm~\ref{alg:smooth_chain_suffix}. Function \textit{isSmoothBlock(B)} checks whether a block $B$ is smooth by calling \textit{isSmoothPointer(B,p)} for every pointer $p$ in $B$'s interlink. Function \textit{isSmoothPointer(B,p)} returns \emph{true} if $p$ is a valid pointer, in essence a pointer to the most recent \emph{smooth velvet} for the level denoted by the pointer itself. The \textit{updateInterlink} algorithm is given in Algorithm~\ref{alg:update_interlink}. It is the same as in the case of a soft fork, but works on the smooth chain $\chain_S$ instead of $\chain$.

The construction of the velvet suffix prover is given in Algorithm~\ref{alg:velvet_suffix_prover}. Again it deviates from the soft fork case by working on the smooth chain $\chain_S$ instead of $\chain$.
Lastly, the Verify algorithm for the NIPoPoW suffix protocol remains the same as in the case of hard or soft fork, keeping in mind that no \emph{previd} links can be followed when verifying the ancestry of the chain to avoid hitting any thorny blocks.

\begin{algorithm}[h]
	\caption{\label{alg:smooth_chain_suffix}Smooth chain for suffix proofs}
	\begin{algorithmic}[1]
			\Function{\sf smoothChain}{$\chain$}
				\Let{\chain_S}{\{\mathcal{G}\}}
				\Let{k}{1}
				\While{$\chain[-k] \neq \mathcal{G}$}
						\If{$\textsf{isSmoothBlock}(\chain[-k])$}
							\Let{\chain_S}{\chain_S \cup \chain[-k]}
						\EndIf
						\Let{k}{k + 1}
				\EndWhile
				\State\Return{$\chain_S$}
			\EndFunction

			\Function{\sf isSmoothBlock}{$B$}
				\If{$B = \mathcal{G}$}
					\State\Return{$\true$}
				\EndIf
				\For{$p \in B.\textsf{interlink}$}
						\If{$\lnot \textsf{isSmoothPointer}(B, p)$}
							\State\Return{$\false$}
						\EndIf
				\EndFor
				\State\Return{$\true$}
			\EndFunction

			\Function{\sf isSmoothPointer}{$B, p$}
				\Let{b}{\textsf{Block}(B.\textsf{prevId})}
				\While{$b \neq p$}
						\If{$\textsf{level}(b) \geq \textsf{level}(p) \land \textsf{isSmoothBlock}(b)$}
							\State\Return{$\false$}
						\EndIf
						\If{$b = \mathcal{G}$}
							\State\Return{$\false$}
						\EndIf
						\Let{b}{\textsf{Block}(b.\textsf{prevId})}
				\EndWhile
				\State\Return{$\textsf{isSmoothBlock}(b)$}
			\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
		\caption{\label{alg:update_interlink}Velvet updateInterlink}
		\begin{algorithmic}[1]
				\Function{\sf updateInterlinkVelvet}{$\chain_S$}
						\Let{B'}{\chain_S[-1]}
						\Let{\textsf{interlink}}{B'.\textsf{interlink}}
						\For{$\mu = 0$ to $\textsf{level}(B')$}
								\Let{\textsf{interlink}[\mu]}{\textsf{id}(B')}
						\EndFor
						\State\Return$\textsf{interlink}$
				\EndFunction
		\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
		\caption{\label{alg:velvet_suffix_prover}Velvet Suffix Prover}
		\begin{algorithmic}
				\Function{\sf ProveVelvet$_{m,k}$}{$\chain_S$}
					\Let{B}{\chain_S[0]}
					\For{$\mu = \lvert \chain_S[-k].\textsf{interlink} \rvert$ down to $0$}
						\Let{\alpha}{\chain_S[{:}-k]\{B{:}\}\upchain^\mu}
						\Let{\pi}{\pi \cup \alpha}
						\Let{B}{\alpha[-m]}
					\EndFor
					\Let{\chi}{\chain_S[-k{:}]}
					\State\Return$\pi\chi$
				\EndFunction
		\end{algorithmic}
\end{algorithm}

\subsubsection{Impossibility of a secure protocol for (1/2)-bounded adversary}
During our study on the problem we failed to prove the security of several protocol
constructions under $(\frac{1}{2})$-bounded adversary. We finally concluded that
such a secure NIPoPoW construction is impossible under velvet fork conditions.
Though it is hard to provide a typical proof for this claim, as one should consider
any possible construction, we try to argue for it in this section.

\textbf{Claim:} \textit{Assume $t$ adversarial out of $n$ total parties and $n_h = g(n-t)$ the number of upgraded honest parties.
There is no construction for NIPoPoW suffix proofs under velvet fork conditions,
which is both succinct and secure for every adversary, such that
$\dfrac{t}{n_h} < (1 - \delta)$.}

\textit{Discussion.} As explained earlier, since the adversary may use the interlink structure so as to include pointers to arbitrary blocks,  she may construct her own
chain history utilizing the non-smooth pointers included in the thorny blocks she
generates. Such an example is given in Figure \ref{fig:generic_attack}.

Let us consider a protocol construction $p$ which allows for NIPoPoW suffix proofs
under velvet fork and is secure for 1/2-bounded adversary. Our main
goals are $p$ to be both secure and succinct. We can even loose our non-interactivity
limitations to make it possible to challenge the submitted proofs, so that an honest
player can contest against an inconsistent proof. However, note that the same power
to challenge any submitted proof is also provided to the adversary.

Now assume an adversary of $ \dfrac{1-\delta}{2} < \dfrac{t}{n_h} < 1-\delta $. Then, as explained
in the Backbone and Selfish Mining papers \cite{backbone}\cite{selfish} it
is possible for the adversary to maintain the longest valid chain being of less
than $50\%$ chain quality in favor of adversarially generated blocks. In particular,
consider that the adversary mines selfish, meaning that for every block she mines
she does not immediately announce it to the network. Instead, she waits until an
honest block is announced. In the worst case, consider an adversary that has a
network advantage regarding the relay of her blocks. Thus in case of two competing
blocks in a round the adversarial one will be appended to the chain, while the
honest block is discarded in practice as a temporary fork. Because of this attack
the total block ratio in the chain will result as illustrated in Figure
\ref{fig:selfish_mining_pie}. For (1/3) adversary half of the blocks in the
chain are expected to be adversarial, while for (1/2) adversary no honest block
is included in the chain in the worst case scenario.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.8]{figures/selfish_mining_pie.pdf}
	\end{center}
	\caption{Pie chart of adversarially and honestly generated blocks appended in 
	the chain during a round set S. Part \textbf{A} stands for blocks mined by the
	adversary while \textbf{B} for blocks mined by honest players. Lined out parts
	denote honestly mined blocks that were defeated by adversarially mined ones in
	the same round due to selfish mining.\textbf{I.} With $t = n/3$, $50\%$ of the
	total blocks are adversarially generated in the worst case scenario. \textbf{II.}
	With $t > n/3$, more than half of the total blocks are adversarially generated in
	the worst case scenario.}
	\label{fig:selfish_mining_pie}
\end{figure}

Observe that the property violated in the chainsewing attack is the $prevId$ relation
between sequential blocks. However since the main purpose of our work is to achieve
succinctness, the \textit{prevId} relations could not be utilized in a viable manner
in order to contest adversarial proofs, as it would require proofs of linear length
to that of the whole chain.  We thus conclude that we should mostly rely on the
information given by the interlink pointers as far as the validity of any proof
is concerned so as to keep our protocol construction efficient.

Now assume, to honest parties' favor, that it is both possible and efficient to inspect
the whole chain history that each block is commited to via its interlink pointers. Keep
in mind that an adversary can keep a consistent chain considering the interlink pointers
by using only her own mined blocks and, at the same time, these blocks may overwhelm
the honestly generated ones. In our protocol $p$ it should be decided  under what policy
an honest party generates blocks and constructs suffix proofs. A decision should be made
for block generation:
\begin{enumerate}
	\item interlink data are neutral as for adversarially and honestly generated blocks
	\item interlink data point out inconsistent blocks, meaning blocks with incorrect interlinks
	\item interlink data exclude inconsistent blocks from being part of the	valid chain formed by the super-pointers
\end{enumerate}
Now let's examine the above choices. \\
In the first case the arguments that an honest player could provide against an
inconsistent proof could only be based on the 0-level pointers. Such a contesting
proof should at least provide the 0-level subchain of length equal to the
following: starting from a block included in the suffix proof and is not a
block of the chain until the closest block included in the suffix proof and is
a valid block of the chain. This means that contesting proofs are expected to
be of length $2^\mu$ where $\mu = log(|C|)$, and subsequently are of complexity
$\mathcal{O}(|C|)$ which ruins the succinctness of our protocol.

In the second case an honest party could utilize this extra information provided
in the interlink to prove an inconsistent proof wrong. However, keep in mind that
the adversary could make such claims too. So, a claim of inconsistency for a
specific block included should be followed by a proof of its inconsistency.
Whatever the information considering the incorrect blocks in the interlink may
be, the adversary could make some of it in her own generated blocks in order to
contest an honest proof too. So we fall to the previous case turning to
\textit{prevId} pointers in order to prove the true chain history, where the
contesting proofs are unacceptable efficiency-wise.

In the third case we demand from the honest players to validate the interlink
structures of the blocks in the chain and exclude the inconsistent ones from
the chain history that the interlinks provide. In this way we could possibly
provide contesting proofs using information only from the interlinks thus
keeping our proofs succinct. This solution would result to two different
chain histories considering the interlink pointers: the one of the honest
parties that includes only blocks with valid interlinks, and the one of the
adversary which may form her own history of invalid blocks probably belonging
to many different underlying chains but could not include honest blocks if at
least one invalid block participates in the proof. This solution seems to bring
us to a notable trade-off point. On the one hand we manage to uncouple from the
0-level blocks. On the other hand, we compromise that honest players cannot use
valid adversarially generated blocks in their proof, while the adversary cannot
include honestly generated blocks in her proofs if inconsistent blocks are also
included. This solution could not work properly for (1/2)-bounded adversary
though. The reason lies in the bad chain quality as pointed out earlier and shown in
Figure \ref{fig:selfish_mining_pie}. If the adversary  could create his own chain
history including inconsistent blocks from two different chains, then she could
easily construct a suffix proof that wins over an honest one because the majority
of the blocks included in the chain could be adversarial with high probability.

We conclude that such a protocol could not exist for (1/2)-bounded adversary.


\subsubsection{Solution for (1/3)-bounded adversary}
The vulnerability that makes this attack possible is the acceptance of thorny
blocks. Since we operate under a velvet fork we cannot eliminate such blocks, 
but we need, however, to restrict the adversary from being able to claim portion
of another chain as part of her own fork chain.The key observation on the
Chainsewing Attack is that the adversary needs at least one adversarially generated
block in an honest player's chain (block $a'$), in order to create a path of
superpointers connecting blocks of two, or more, diverse chains. The final proof
chain will make use of this crossing point and may contain both honest or
adversarial blocks.
%% intuitive reference to 1/4 adversary
In case the proof contains only adversarial blocks, the attack cannot harm
security for an adversary of less than $1/3$ of the total hashing power. This
fact will be clear in the security proof section. In short, as argued in the
previous section an adversary of $1/3$ of the total hashing power may contribute
at most $ 50\% $ of the total blocks in the longest valid chain. An attacker of
more than $1/3$ hashing power could dominate as of total hashing power expressed
in mined blocks in the chain, while the inverse would be true for an attacker of
less hashing power than this threshold.

So in order to be successful, the attacker needs to also ``sew`` honestly generated
blocks. Thus there will be at least one honest block in the superblock path which
connects $a$ and $a'$, pointing to an adversarial thorny block.

The idea is to ban all blocks generated by honest players from participating in
this superblock path. In this way the adversary could not misuse hashing power of
the honest players and the sewed blocks could only be adversarially generated,
thus the attack could never succeed for an adversary of less than $1/3$ of the
total hashing power.
